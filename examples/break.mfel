let range = @std.iter.range;

function f2(i) {
    # the break is caught here (at function top-level it is like a return)
    break i*100;
    @println("in f2: will never print");
}

function f1(x,a,b) {
    for i in range(a,b) {
        if i > x { 
            # also works inside a second block...
            # because the block returns a "Break" result to the if and
            # this propagates to the for
            { 
                let r2 = f2(i); # the break inside f2 does not affect us
                @println("in f1: f2 returned ",r2);
                @println("in f1: will break");
                # this pushes the value of i up until it hits a loop or a function body
                # the loop or function will abort and return what the break statement pushed up
                break i; 
                @println("in f1: will never print");
            }
        };
        i
    }
    # the loop will return the value pushed by break or the last expression (i in this case)
};

@test("f1(5,1,9)",6);
@test("f1(15,1,9)",8);

