### @context() captures the current state of all variables by reference
### (this is what happens internally when a lambda is defined)
### the captured context inherits the global one
###
### @self simply points to the current context
###

let x = 1;
let y = 2;

@println("test 1");

@set(@context(),"y",y+x);
@set(@context(),"y",@get(@context(),"y")+@get(@context(),"x"));
# y is changed because the capture is by reference
@test("@get(@context(),\"y\")",4);
@test("y",4);

@insert(@context(),"z",3);
@test("@type(z!)","Error"); # exclam catches and unwraps an exception
# z not found (it was inserted in the captured context that is gone now)

@insert(@self,"zz",3);
@test("zz",3);
# @self manipulates the current context
# @context() returns a new context with pointers to existing values

@println();


@println("test 2");
let c = @context(); # captured to c
@test("x",1);
@test("c.x",1);
@println();

@println("test 3");
@insert(c,"x",100);
# this x shadows the old one only inside c
@test("x",1);
@test("c.x",100);
@println();

@println("test 4");
# the global x is changed but the one inside x has been shadowed above
x += 1;
@test("x",2);
@test("c.x",100);
@println();

@println("test 5");
# the x inside c is incremented
@set(c,"x",@get(c,"x") + 1);
@test("x",2);
@test("c.x",101);
@println();

@println("test 6");
# the global x is shadowed
let x = x + 1;
@test("x",3);
@test("c.x",101);
@println();

@println("test 7");
# x is shadowed again inside c
@insert(c,"x",10);
@test("x",3);
@test("c.x",10);
@println();

#@self
