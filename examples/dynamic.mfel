### a quick test to show the difference between dynamic and lexical binding

let x = 1;
let y = 100;
let z = 1000;

# the fun captures references to x and y at definition (with ...)
# z is a parameter so it always gets bound when calling
let lex = fun z with x y { x+y+z };

# here, x and y are not captured (default behavior)
# z is a parameter so it always gets bound when calling
let dyn = \z -> x+y+z;

# here, we shadow y (this is another y, the older y is still captured by the first lambda)
let y = 10;

# here we have an example of dynamic fall back binding:
#  dyn did not capture x and y so it will look them up here
#  (it sees the new y binding)
@test("dyn(10)",21);

# the lexical closure sees the old y binding that was captured by reference
@test("lex(10)",111);

# but if we mutate x instead of shadowing it, they have similar behavior
x = 2;
# dyn looks up x here so it sees the change
@test("dyn(10)",22);
# lex has a reference to the global x so it sees the change
@test("lex(10)",112);
