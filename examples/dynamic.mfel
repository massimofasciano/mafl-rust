### a quick test to show the difference between
### - staticfn: static function with only local variables (can't call other functions if not passed as args)
### - lambda: function that captures the context in which it is defined
### - dynfn: function that captures the context in which it is evaluated

let x := 1;
let y := 100;
let z := 1000;

let dyn := dynfn(z) {x+y+z};

# useless here because a staticfn is run in an empty context (all variables are local)
let sta := staticfn(z) {x+y+z};
# it's equivalent to
#let sta := context () in lambda(z) {x+y+z};

let clo := lambda(z) {x+y+z};

# here, we shadow y (this is another y, the older y is still captured by the lambda)
let y := 10;

# the dynamic function is evaluated in the current context (it sees the new y binding)
@println("dynamic: ",dyn(10));

# this always fails...
#@println("static: ",sta(10));

# the lambda is evaluated in the context where it was defined (it sees the old y binding)
@println("lambda: ",clo(10));

# but if we mutate x instead of shadowing it, they have similar behavior
x := 2;
@println("dynamic: ",dyn(10));
@println("lambda: ",clo(10));
