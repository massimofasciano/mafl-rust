### a fun is a nameless function
### it captures references to bindings in the definition context
### (ex: "... with x y" captures x and y by reference)

let g = 0;
@println("g = ",g);

### here are a few ways of declaring functions:

# function has one argument "x" and will evaluate "g" at call time in the context of the caller (dynamic binding)
let f1 = fun x { x + 10 + g };

# function has one argument "x" and captures a reference to "g" at definition time (lexical binding)
# if g is changed in the ouside context, the function will see the new value
# if g is changed inside the function, the global context will see the new value
# if a new "g" is defined outside (via let statement), the function still operates on the one that was captured
let f2 = fun x with g { x + 10 + g };

# almost a shortcut for: fun x { x + 10 + g }
# the difference is that x + 10 + g is not evaluated inside a bock context
# this can have subtle differences when certain statements like "return" or "break" are used
# no captures possible here
let f3 = \x -> x + 10 + g;

# when more than 1 argument is needed, any whitespace can separate them
let f4 = fun x y z with a b c { x*a + b/y + z/c };

# sometimes, we need to refer to ourselves for recursive calculations
# this is possible in an anonymous function via the "as" keyword
# the variables after "as" are bound to a circular reference to the function
let f5 = fun x with g as self {
    if x <= 1 {
        x
    } else {
        x * self(x-1)
    }
};

# without this self-referencing, recursion is still possible via the default dynamic
# binding, as long as the name of the variable that refers to the function is not changed.
# in the example above, we could refer to f5 for recursion without using "as" but the
# f5 variable needs to point to our function when it is called, even if our function
# is called under another name. let's do this for f6...
let f6 = fun x with g {
    if x <= 1 {
        x
    } else {
        x * f6(x-1)
    }
};

### note that "let" is not self-delimiting so it needs a semicolon
###  when used as a statement

### a defun (function definition) is a syntactic shortcut for
###  assigning a fun (function) to a variable
### 2 important differences:
###  - no semicolon necessary (self-delimiting)
###  - it binds its name to the fun (for safe recursion
###    without depending on external context at call site)

# this is a shortcut for: let f6 = fun x with g as f6;
defun f10 x with g { 
    x + 10 + g
}

@test("f1(0)",10);
@test("f10(0)",10);

# we are changing this inside the environment that is captured by the lambdas
g += 1; 
@println("g = ",g);

@test("f1(0)",11);
@test("f10(0)",11);

# we are adding a new binding called "g" (it shadows the old one)
# this will not change the binding that was captured by the functions.
let g = g + 1; 
@println("g = ",g);

@test("f1(0)",12); # f1 did not capture g at definition
@test("f10(0)",11);

@println();
let f5copy = f5;
@test("f5copy(4)",24);
let f5 = \x -> x;
@test("f5copy(4)",24);

@println();
let f6copy = f6;
@test("f6copy(4)",24);
let f6 = \x -> x;
@test("f6copy(4)",12);
