# f1 has an open reference to f2
defun f1 x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# f2 has captured f1
defun f2 x with f1 {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}

# the mutual recursion works because we fall back
# to the context at the call site

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# let's keep references to both functions so we can rebind the names later...
let f1c = f1;
let f2c = f2;

# we can safely redefine f1 and f2 will still call the captured original
let f1 = \x -> x;

@test("f1c(5)",5);
@test("f1c(15)",-15);
@test("f1c(25)",25);

# we restore f1
let f1 = f1c;

# but if we redefine f2, f1 will call the new one
let f2 = \x -> x;

@test("f1(5)",5);
@test("f1(15)",15); # the wrong f2 is called
@test("f1(25)",25);

# we restore f2
let f2 = f2c;

# we bind the name f2 inside of f1 to the original f2
bind f2 in f1;

# now if we redefine f2, f1 will call the correct version
let f2 = \x -> x;

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# we restore f2
let f2 = f2c;

# we can inspect the captured contexts for f1 and f2...
#@println(f1);
#@println(f2);

###
### another way of doing mutual recursion...
###

let f = {
    let rec2;
    let rec = fun x with rec2 as rec { 
        if x > 10 { rec2(x) }
        else { rec(x+1) }
    };
    rec2 = fun x with rec {
        if x > 20 {
            rec(x // 10)
        } else {
            x * 10
        }
    };
    rec
};

@test("f(1)",110);
@test("f(50)",110);
#@println(f);