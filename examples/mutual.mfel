###
### mutual recursion can be performed via dynamic or lexical bindings
### both methods are shown here...
###

###
### 1- dynamic binding
###

# f1 has an open reference to f2
defun f1 x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# f2 has captured f1
defun f2 x with f1 {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}

# the mutual recursion works because we fall back
# to the context at the call site (dynamic binding)

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# let's keep references to both functions so we can rebind the names later...
let f1c = f1;
let f2c = f2;

# we can safely redefine f1 and f2 will still call the captured original
let f1 = \x -> x;

@test("f1c(5)",5);
@test("f1c(15)",-15);
@test("f1c(25)",25);

# we restore f1
let f1 = f1c;

# but if we redefine f2, f1 will call the new one
let f2 = \x -> x;

@test("f1(5)",5);
@test("f1(15)",15); # the wrong f2 is called
@test("f1(25)",25);

# we restore f2
let f2 = f2c;

###
### 2- dynamic binding
###

# f1 has a closed reference to f2 (bound to nil for now)
defun f1 x with f2 {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# f2 has captured f1 and changed the f1.f2 reference after defining itself
defun f2 x with f1 in f1 {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}

# the mutual recursion works because each function has
# a captured reference to the other (lexical binding)

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# let's keep references to both functions so we can rebind the names later...
let f1c = f1;
let f2c = f2;

# we can safely redefine f1 and f2 will still call the captured original
let f1 = \x -> x;

@test("f1c(5)",5);
@test("f1c(15)",-15);
@test("f1c(25)",25);

# we restore f1
let f1 = f1c;

# we can safely redefine f2 and f1 will still call the captured original
let f2 = \x -> x;

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# we restore f2
let f2 = f2c;
