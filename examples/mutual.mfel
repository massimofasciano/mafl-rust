# f1 has an open reference to f2
function f1(x) {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# f2 has captured f1
function f2(x) {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}
#bind f2 in f1; # let's do this later in the example...

# the mutual recursion works because we fall back
# to the context at the call site

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# let's keep references to both functions so we can rebind the names later...
let f1c = f1;
let f2c = f2;

# we can safely redefine f1 and f2 will still call the captured original
function f1(x) {
    x
}

@test("f1c(5)",5);
@test("f1c(15)",-15);
@test("f1c(25)",25);

# we restore f1
let f1 = f1c;

# but if we redefine f2, f1 will call the new one
function f2(x) {
    x
}

@test("f1(5)",5);
@test("f1(15)",15); # the wrong f2 is called
@test("f1(25)",25);

# we restore f2
let f2 = f2c;

# we bind the name f2 inside of f1 to the original f2
bind f2 in f1;

# now if we redefine f2, f1 will call the correct version
function f2(x) {
    x
}

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# we restore f2
let f2 = f2c;

# we can inspect the captured contexts for f1 and f2...
#@println(f1);
#@println(f2);

###
### a simpler way using only let and lambda
###

let f = context () { # a simple block works too but captures the outside context too
    let rec;
    let rec2;
    rec = \x { # alternate lambda syntax
        if x > 10 { rec2(x) }
        else { rec(x+1) }
    };
    rec2 = \(x) { # alternate lambda syntax
        if x > 20 {
            rec(x // 10)
        } else {
            x * 10
        }
    };
    rec
};

@test("f(1)",110);
@test("f(50)",110);
#@println(f);