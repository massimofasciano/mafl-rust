# lambda captures context at definition (so it can't directly call itself)
# but symbol lookups fall back to the calling context
let fibo1 = lambda (x) {
    if x < 2 {
        x
    } else {
        fibo1(x-2) + fibo1(x-1)
    }
};

# here fibo1 exists at the call site, so the recursive call works
@test("fibo1(10)",55);

# fibo1 under another name
let fibo1copy = fibo1;
@test("fibo1copy(10)",55);

# we replace fibo1 at the call site
let fibo1 = lambda (x) { 0 };
# this will return 0 because the recursive call to fibo1 was shadowed above
@test("fibo1copy(10)",0);

@println("**************************************************");

# lambda captures context at definition (so it can't directly call itself)
# but symbol lookups fall back to the calling context
# alternate lambda syntax with \ and single argument
let fibo2 = \x {
    if x < 2 {
        x
    } else {
        fibo2(x-2) + fibo2(x-1)
    }
}; 
# inserts binding for fibo2 into the fibo2 lambda (for recursion)
bind fibo2;

# we could also use...
#bind fibo2 = fibo2 in fibo2;
#bind fibo2 in fibo2;

#@println(fibo2);

@test("fibo2(10)",55);

# fibo2 under another name
let fibo2copy = fibo2;
@test("fibo2copy(10)",55);

# we replace fibo1 at the call site
let fibo2 = lambda (x) { 0 };
# this works because a lambda carries it's context around
@test("fibo2copy(10)",55);

@println("**************************************************");

# this creates a lambda with a circular reference to it's own name
# it's syntactic sugar for the let + bind used for fibo2 above
function fibo3(x) {
    if x < 2 {
        x
    } else {
        fibo3(x-2) + fibo3(x-1)
    }
}

@test("fibo3(10)",55);

# fibo3 under another name
let fibo3copy = fibo3;
@test("fibo3copy(10)",55);

# we replace fibo1 at the call site
let fibo3 = lambda (x) { 0 };
# this works because a lambda carries it's context around
@test("fibo3copy(10)",55);

@println("**************************************************");

