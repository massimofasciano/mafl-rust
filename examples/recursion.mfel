# dynamic function evaluates in caller's context
let fibo1 := dynfn (x) {
    if x < 2 {
        x
    } else {
        fibo1(x-2) + fibo1(x-1)
    }
};

@println(fibo1(10));

let fibo1copy := fibo1;
@println(fibo1copy(10));
let fibo1 := lambda (x) { 0 };
# this will return 0 because the recursive call to fibo1 was shadowed above
@println(fibo1copy(10));

@println("**************************************************");

# lambda captures context at definition (so it can't call itself)
let fibo2 := lambda (x) {
    if x < 2 {
        x
    } else {
        fibo2(x-2) + fibo2(x-1)
    }
}; 
@bind(fibo2,"fibo2",fibo2); # inserts binding for fibo2 into the fibo2 lambda (for recursion)

# warning: trying to print the fibo2 lambda after binding
# to itself will cause an infinite loop (referential cycle on fibo2).
# TODO: a patched version of print removes all of the values from the bindings
#  until we implement a cycle-aware print.
#@println(fibo2);

@println(fibo2(10));

let fibo2copy := fibo2;
@println(fibo2copy(10));
let fibo2 := lambda (x) { 0 };
# this works because a lambda carries it's context around
@println(fibo2copy(10));

@println("**************************************************");

# this creates a lambda with a circular reference to it's own name
# it's syntactic sugar for the let + bind used for fibo2 above
def fibo3(x) {
    if x < 2 {
        x
    } else {
        fibo3(x-2) + fibo3(x-1)
    }
}

@println(fibo3(10));

let fibo3copy := fibo3;
@println(fibo3copy(10));
let fibo3 := lambda (x) { 0 };
# this works because a lambda carries it's context around
@println(fibo3copy(10));

@println("**************************************************");

