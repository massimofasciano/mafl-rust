# we don't capture the fibo1 name inside the closure
let fibo1 = fun x {
    if x < 2 {
        x
    } else {
        fibo1(x-2) + fibo1(x-1)
    }
};

# here fibo1 exists at the call site, so the recursive call works
@test("fibo1(10)",55);

# fibo1 under another name
let fibo1copy = fibo1;
@test("fibo1copy(10)",55);

# we replace fibo1 at the call site
let fibo1 = \x -> 0;
# this will return 0 because the recursive call to fibo1 was shadowed above
@test("fibo1copy(10)",0);

@println("**************************************************");

# here we capture a circular reference to fibo2 inside the closure
let fibo2 = fun x as fibo2 {
    if x < 2 {
        x
    } else {
        fibo2(x-2) + fibo2(x-1)
    }
}; 

#@println(fibo2);

@test("fibo2(10)",55);

# fibo2 under another name
let fibo2copy = fibo2;
@test("fibo2copy(10)",55);

# we replace fibo1 at the call site
let fibo2 = \x->0;
# this works because a closure carries it's context around
@test("fibo2copy(10)",55);

@println("**************************************************");

# this is just syntactic sugar for what we did for fibo2
defun fibo3 x {
    if x < 2 {
        x
    } else {
        fibo3(x-2) + fibo3(x-1)
    }
}

@test("fibo3(10)",55);

# fibo3 under another name
let fibo3copy = fibo3;
@test("fibo3copy(10)",55);

# we replace fibo1 at the call site
let fibo3 = \x -> 0;
# this works because a closure carries it's context around
@test("fibo3copy(10)",55);

@println("**************************************************");

