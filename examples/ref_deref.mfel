###
### the language has a reference type that links mutably to the storage cell of another value
### &x returns a reference to x
### $y derefs y (if y is &x, $y will return the contents of x)
### y <- expr mutates the storage cell that reference y points to
###

let v = 200;  # v is bound to a storage cell S1 containing a reference to the value 200
let r = &v;   # r is bound to a storage cell S2 containing a reference to the cell S1 above
let c = v;    # v is bound to a another storage cell S3 containing a reference to the value 200

# so to simplify, we now have 2 "boxes" S1 and S3 with the value 200 and a box S2 referencing box S1.
@println(v," ",c," ",r);

# we add 1 to the value inside cell S3 so now the value of c is 201
c = c + 1;
@println(v," ",c," ",r);

# we add 10 to the value inside cell S1 so now the value of v is 210
# but r also points to the same cell via an indirection layer
# this is shown as ->210 when the value of r is printed here
v = v + 10;
@println(v," ",c," ",r);

# here, we use the deref operator $ to fetch the value referenced by r (the contents of cell S1 via cell S2)
# we add 100
# and then we store the contents not the cell of r (S2) but in the cell pointed to by the cell of r (S1)
# so now v is 310 (cell S1) and r still points to it
r <- $r + 100;
@println(v," ",c," ",r);

# here we take a reference to c and add 1 through that reference
# we do it inside a block scope so that q is only temporary
{ let q = &c; q <- $q + 1; }
# this adds 1 to c
@println(v," ",c," ",r);

# a function that tests if it has a reference and increments through it
# if it's not a ref, the increment is only local
let reftest = \r {
    if @is_ref(r) {
        r <- $r + 1;
    } else {
        r = r + 1;
    }
    @println("inside: ",r);
};

# v will not change
reftest(v);
@println("outside: ",v);

# v will change
reftest(&v);
@println("outside: ",v);

# here we deref r and add 50 but we place the result in cell S2
# so r is not a reference anymore...
r = $r + 50;
@println(v," ",c," ",r);

let o = object {
    let x = 1;
    let y = 2;
    let __str__ = \{"(" + x + "," + y + ")"}
};
# we can also take a ref on an object field
let p = &(o.x);
@println(o);
p <- 3;
@println(o);
# but not on array elements (as of MFEL 0.3.2)

