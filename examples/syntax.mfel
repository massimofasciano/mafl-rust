###
### let: create variable bindings
###

# this binds the name x to a memory cell containing the value 10
let x = 10;

# this binds the name x to another memory cell containing the value 20
# the previous x is still there but shadowed.
let x = 20;
# this becomes even more important when using nested code blocks with local scopes

###
### assign and op-assign: change variable bindings
###

let x = 10;

# this changes the content of the memory cell of x and places 20 into it
x = 20;

# a shortcut for x = x + 1;
# adds 1 to the value inside the cell
x += 1;
# many other op-assign combos exist like *= /= -= etc...

###
### unit testing
###

# the @test builtin function can be used for simple unit tests
let x = 2;
let y = 3;
@test("x + y",5);
# it takes a string as first argument and will treat it as a program to be parsed and evaluated inside 
# the current context. the result is compared to the second argument and a diagnostic message is printed:
# test success: x + y == 5

###
### fun: create anonymous functions
###

# closed function: 3 arguments x, y and z
let f = fun x y z { x + y * z };
# f(1,2,3) will return 1 + 2 * 3 = 7 (no outside effects)

# open function: 2 arguments x and y, 1 open variable z
# the value of z will be looked up when the function is called
# (dynamic binding by default)
let f = fun x y { x + y * z };

# after defining the function, the latest binding for z will be used
let z = 10;
@test("f(1,2)",21);

# closed function: 2 arguments x and y, 1 captured variable z
# a reference to z will be looked up when the function is defined
# and will be kept inside a closure (lexical binding per variable)
let z = 40;
let f = fun x y with z { x + y * z };
@test("f(1,2)",81);

# if the original z is modified, the function will see the change because
# it kept a reference to it. the function can also change z and the outside
# context will see this change in the original.
z += 1;
@test("f(1,2)",83);

# if z is shadowed by a new binding after the function is defined, the old value is used
let z = 50;
@test("f(1,2)",83);

# something like this can be used to create an iterator
let counter = {
    let count = 0;
    fun with count {
        # this function captures a reference to the 
        # count variable and can update it when called
        count += 1;
        count
    }
};
@test("counter()",1);
@test("counter()",2);
@test("counter()",3);

# another way to write the same counter with the "persist" keyword
# it creates persistent (like C static) variables inside the function
let counter = fun persist (count=0) {
    count += 1;
    count
};
@test("counter()",1);
@test("counter()",2);
@test("counter()",3);

# we can also alias a capture (here we capture a reference to w under the name z)
let z = 60;
let w = 70;
let f = fun x y with (z=w) { x + y * z };
@test("f(1,2)",141);

# when we need to refer to our anonymous function recursively, we can use the "as" keyword
let f = fun x as rec {
    if x <= 1 { x } else { x * rec(x-1) }
};
@test("f(4)",24);
# works even if we change f1
let g = f;
let f = fun x { 0 };
@test("g(4)",24);

# we could also rely on dynamic binding for the recursive call
let f = fun x {
    if x <= 1 { x } else { x * f(x-1) }
};
@test("f(4)",24);
# but this will fail if the name f is redefined
let g = f;
let f = fun x { 0 };
@test("g(4)",0); # we would like to get 24
# dynamic binding is not reliable

###
### defun
###

# defun is a shortcut for let f = fun ... as f (more or less)
let f = fun x as f {
    if x <= 1 { x } else { x * f(x-1) }
};
# we often define functions so some syntactic sugar is worth it
defun f x {
    if x <= 1 { x } else { x * f(x-1) }
};
# we also get the circular binding on the name of the function 
# in case we need to recurse
@test("f(4)",24);

# a few differences: 
# - defun doesn't have an "as" clause (it's built in)
# - defun has an "in" clause to help with mutual recursion

# f1 has a persistent (and closed) reference to f2 (bound to nil for now)
defun f1 x persist f2 {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# f2 has captured f1 (with f1) and changed the f2 reference 
# inside f1 (in f1) to point to f2
# (f1 needs to have a persistent slot for this to work)
defun f2 x with f1 in f1 {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}
# this is another level of syntactic sugar for:
#defun f2 x with f1 { ... }
#f1.f2 = f2;

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

# once again, this mutual recursion would have worked using dynamic binding
# with no extra effort but by forcing mutual capture of function references,
# we make sure that any changes in the outside environment will not break
# the calls.

# open variable f2 left for dynamic binding
defun f1 x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}

# open variable f1 left for dynamic binding
defun f2 x {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);

###
### a shortcut for small functions: \ ... -> expr
###

let f = \x -> x + 1;
# equivalent to let f = fun x { x + 1 }
@test("f(1)",2);

# works with multiple arguments
let f = \x y z -> x * y * z;
@test("f(1,2,3)",6);

# works with no arguments (but looks strange)
let f = \->1;
@test("f()",1);

# this shortcut only allows fully closed functions
# it looks good when passing a function to another function (with map, filter, etc...)

###
### code blocks
###

# we have seen blocks in the section about functions but code blocks can be used anywhere
# in place of an expression. they create a local scope for variables.

let x = 20;
@test("x",20);
{
    x += 1; # we are still working on the same x as outside
    @test("x",21);
    let x = 30;
    x += 1; # we are working on a local binding of x that shadows the other
    @test("x",31);
}
# as soon as we exit the block, the old binding comes back
@test("x",21);

# a code block has a value as an expression: the value of the last item in the block
let v = { 
    let x = 20;
    x += 2;
    x
};
@test("v",22);

# note that we did not put a semicolon on the last expression
# if we put one, it would be equivalent to having an implicit nil 
# as the last expression in the block
let v = { 
    let x = 20;
    x += 2;
    x; # this does nothing but it's valid
};
@test("v",nil);

###
### context with ... {...} is a shortcut for fun with ... {...}()
### object {...} is a shortcut for fun {...; @self}
### module m {...} is a shortcut for let m = object {...};
###
