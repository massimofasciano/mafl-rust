###
### let: create variable bindings
###

@println("*** LET ***");

# this binds the name x to a memory cell containing the value 10
let x = 10;

# this binds the name x to another memory cell containing the value 20
# the previous x is still there but shadowed.
let x = 20;
# this becomes even more important when using nested code blocks with local scopes

###
### unit testing
###

@println("*** UNIT TESTING ***");

# the assert statement can be used for simple unit tests
let x = 2;
let y = 3;
test x + y expect 5;
# test success x + y: result 5

###
### assign and op-assign: change variable bindings
###

@println("*** ASSIGN ***");

let x = 10;
test x expect 10;

# this changes the content of the memory cell of x and places 20 into it
x = 20;
test x expect 20;

# a shortcut for x = x + 1;
# adds 1 to the value inside the cell
x += 1;
test x expect 21;
# many other op-assign combos exist like *= /= -= etc...

###
### fun: create anonymous functions
###

@println("*** FUN ***");

# closed function (no external variables): 3 arguments x, y and z
let f = fun x y z { x + y * z };
# you call a function by using a variable bound to it,
# followed by a comma separated list of arguments between a pair of parentheses.
test f(1,2,3) expect 7;

# open function: 2 arguments x and y, 1 free variable z
# a reference to z will be looked up when the function is defined
# and will be kept inside a closure (lexical binding)
let z = 40;
let f = fun x y { x + y * z };
test f(1,2) expect 81;

# if the original z is modified, the function will see the change because
# it kept a reference to it. the function can also change z and the outside
# context will see this change in the original.
z += 1;
test f(1,2) expect 83;

# if z is shadowed by a new binding after the function is defined, the old value
# is still used by the function.
let z = 50;
test f(1,2) expect 83;

# so a function acts as storage for captured variables. this is
# similar to an object or struct, but the captures are by reference.

# something like this can be used to create an iterator.
let counter = {
    let count = 0;
    fun {
        # this function captures a reference to the 
        # count variable and can update it when called.
        # the add-assign as an expression returns the
        # new value after mutation.
        count += 1 
    }
};

# each time the function is called, it returns a different value.
# the analogy with objects is quite clear here.
test counter() expect 1;
test counter() expect 2;
test counter() expect 3;

# when we need to refer to our anonymous function recursively, we can use the capture trick...
# - declare f (defaults to nil)
# - the fun expression will capture it by reference
# - store the function in the memory cell that was captured (circular reference)
let f;
f = fun x {
    if x <= 1 { x } else { x * f(x-1) }
};
test f(4) expect 24;
# works even if we change f
let g = f;
let f = fun x { 0 };
test g(4) expect 24;

# the "let rec" shortcut does this for us...
let rec f = fun x {
    if x <= 1 { x } else { x * f(x-1) }
};
test f(4) expect 24;
# works even if we change f
let g = f;
let f = fun x { 0 };
test g(4) expect 24;

# we can do mutual recursion (2 functions calling each other) with
# a variant of the capture trick...

# f1 captures the reference to f2 (bound to nil for now)
let f2;
let f1 = fun x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
};
# f2 has captured f1 and replaced the f2 captured inside f1
f2 = fun x {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
};
# we could also directly modify the f2 binding
# that is captured in f1 (if we had used let instead
# of assignment when declaring f2)
# f1.f2 = f2;

test f1(5) expect 5;
test f1(15) expect -15;
test f1(25) expect 25;

###
### a shortcut: \ instead of fun
###

@println("*** \\ = fun ***");

let f = \x{x+1};
# equivalent to let f = fun x { x + 1 }
test f(1) expect 2;

# works with multiple arguments and can use commas if it looks better
let f = \x,y,z{x*y*z};
test f(1,2,3) expect 6;

# works with no arguments
let f = \{1};
test f() expect 1;

# this short syntax looks good when passing a function to another function (with map, filter, etc...)

###
### currying
###

@println("*** CURRYING ***");

# when arguments are missing in a function call, currying is performed automatically

let add = \x,y{x+y}; # a 2-arg function
let add5 = add(5);

test add(2,3) expect 5;
test add5(2) expect 7;

# extra arguments are also handled automatically when it makes sense to do so

let add = \x{\y{x+y}}; # a 1 arg function returning a 1 arg function
let add5 = add(5);

test add(2,3) expect 5;
test add5(2) expect 7;


###
### code blocks
###

@println("*** BLOCKS ***");

# we have seen blocks in the section about functions but code blocks can be used anywhere
# in place of an expression. they create a local scope for variables.

let x = 20;
test x expect 20;
{
    x += 1; # we are still working on the same x as outside
    test x expect 21;
    let x = 30;
    x += 1; # we are working on a local binding of x that shadows the other
    test x expect 31;
}
# as soon as we exit the block, the old binding comes back
test x expect 21;

# a code block has a value as an expression: the value of the last item in the block
let v = { 
    let x = 20;
    x += 2;
    x
};
test v expect 22;

# note that we did not put a semicolon on the last expression
# if we put one, it would be equivalent to having an implicit nil 
# as the last expression in the block
let v = { 
    let x = 20;
    x += 2;
    x; # this does nothing but it's valid
};
test v expect nil;

###
### special functions: cons, module and dyn
### 

@println("*** SPECIAL FUNCTIONS: CONS ***");

# we saw in the section about functions that they capture bindings by reference,
# acting like objects.

# let's talk about a few constructs that will be useful:
# 1- @self
# 2- dot notation for field access

# we have a builtin variable called @self that always refers to the current execution context
# (all of the active variable bindings).
# we can use the dot notation to access a variable inside a context, and this applies to @self also.

let s = 1;
# the variable s captured by the current context is the variable s (trivial)
test @self.s expect s;

# let's create a function and set a few local bindings inside
let pf = fun x {
    let y = x + 1;
    # at this point, our local context has:
    # - x: passed when called
    # - y: created inside the function
};
let pv = pf(5);
# what we did is useless because the function returns nil (last statement terminated by semicolon)
test pv expect nil;

# let's make the function return a copy of its active context instead:
let pf = fun x {
    let y = x + 1;
    @self
};
let pv = pf(5);
# at this point, pv is not nil but instead it's a closure
# that captures the environment inside pf when it finished (with x and y bound).

# this is really starting to look like an object or a struct (with fields)...
test pv.x expect 5;
test pv.y expect 6;

# what we created is called a constructor. it's a function that returns a context that
# can be used as an object.

# we have a shortcut for this (cons instead of fun):
let pf = cons x {
    let y = x + 1;
};
let pv = pf(5);
test pv.x expect 5;
test pv.y expect 6;
# with cons we can build instances/ojects/structs

@println("*** SPECIAL FUNCTIONS: MODULE ***");

# another special shortcut exists for the following special case:
# we want to create a namespace (something like a package/module).

# we could do this with cons by using no arguments and
# immediately calling the constructor to get an instance.
let m = cons {
    let inv = \x{1/x};
}();
test m.inv(2) expect 0.5;

# a shortcut called module exists for this:
let m = module {
    let inv = \x{1/x};
};
test m.inv(2) expect 0.5;

# cons and module are just nice syntax. fun can cover both cases and more.

# with the use and from...use constructs, we can inherit/capture bindings:
let m2 = module {
    use pv;
    from m use inv;
    let x = pv.x;
    let y = pv.y;
};
pv.x += 10; 
# by changing pv.x we also affect m2.pv.x because they are bound by reference
test m2.pv.x expect 15;
# but m2.x is a copy
test m2.x expect 5;
# the inv function is inherited
test m2.inv(m2.y) expect 1/6;

@println("*** SPECIAL FUNCTIONS: DYN ***");

# we have seen that functions are basically objects (they have data and code)

# sometimes, we don't want to capture any state at evaluation time but leave the 
# binding of the variables to the call site: this is what dyn is for.

let g = 10;
let ffun = fun x { g + x };
let fdyn = dyn x { g + x };

test ffun(5) expect 15;
test fdyn(5) expect 15;

# we shadow g (bring another g into scope)
# this is not the same thing as mutating the value of the old g
let g = 20;
# fun binds any variable at definition time (it captures a ref to the g that was in scope)
test ffun(5) expect 15;
# dyn evaluates variables at call time
test fdyn(5) expect 25;

###
### base types
###

@println("*** BASE TYPES ***");

# integer
test 1+1 expect 2;
test 5//2 expect 2; # integer division
test 13%4 expect 1; # modulo

# float
test 1/2 expect 0.5;
test 4.5*2 expect 9;

# boolean
test true;
test not false;
test 1 < 3;

# character and string
let s = "hello there!";
test "hello" + " " + "there" + "!" expect s;
test s[1] expect 'e';
test s[-1] expect '!';

# array
let arr = [1,2,3,4,5];
arr[3] += 10;
test arr expect [1,2,3,14,5];

# closure (the result of evaluating a fun/cons/module)
# it bevaves like an object with fields
let o = module {
    let x = 1;
    let y = 2;
};
test o.x+o.y expect 3;
let c = cons x y {
    let __str__ = \{ x + ":" + y }
};
let c1 = c(1,2);
let c2 = c(2,3);
test c1.y expect c2.x;
test c1.__str__() expect "1:2";

###
### standard library vs builtin functions
###

@println("*** BUILTINS AND STD ***");

# we need special builtin functions to perform operations that cannot be written in the language
# for example: 
# - operating system interaction
# - operations on atomic types
# - faster versions of functions

# here are a few examples of builtin functions (there are many more in the source code of the interpreter)

@println(c1," ",c2," ",o.x); # converts all arguments to strings and prints a concatenation of them
# this prints: 1:2 2:3 1
# note that when an object has a __str__ method, it is called by println

# @readline() reads a line from the terminal and returns it as a string

let s = "hi there!";
let a = [1,2,3,4];
test @len(s) expect 9;
test @len(a) expect 4;

test @string(3) expect "3";
test @array(3,1) expect [1,1,1];
test @array(3,\x{x+1}) expect [1,2,3];
test @array("hello") expect ['h','e','l','l','o'];

test @lines("line1\nline2") expect ["line1","line2"];

let s = "1,2,3, 4,5 ,6";

# split a string using a delimiter (basic string)
let delim = ",";
let parts = @split(s,delim);
test parts expect ["1","2","3"," 4","5 ","6"];

# trim whitespace before and after strings
let trimmed = @std.iter.map(@trim,parts);
test trimmed expect ["1","2","3","4","5","6"];

# split a string using a delimiter (regular expression)
let rdelim = "[ ,]+";
let parts_regex = @split(s,rdelim);
test parts_regex expect ["1","2","3","4","5","6"];

# gather all strings matching regular expression
let regex = "[0-9]+";
let matches = @matches(s, regex);
test matches expect ["1","2","3","4","5","6"];

# we have already seen the @self special variable

# the @std special variable points to a module that is
# built into the interpreter but using native language
# constructs instead of interpreter (Rust) code.

from @std.array use map fold;
test map(\x{1/x},[1,2,3,4,5]) expect [1,1/2,1/3,1/4,1/5];
test fold(\a,x{a+x},0,[1,2,3,4,5]) expect 15;

###
### basic control
###

@println("*** BASIC CONTROL ***");

# if with optional else
let rec f = fun x {
    if x < 2 { 
        x 
    } else {
        2 * f(x - 1)
    }
};
test f(5) expect 16;
# unless is if with the test inverted and no else block

# while
let r = 10;
let i = r;
while i > 0 {
    r *= i;
    i -= 1;
}
test r expect 36288000;

# do ... while (test) has the test after the body
let r = 10;
let i = r;
do {
    r *= i;
    i -= 1;
} while (i > 0);
test r expect 36288000;

# loop is an infinite loop. you can only escape with exceptions (break, return, etc...)
let r = 10;
let i = r;
loop {
    if i <= 0 { break; } 
    r *= i;
    i -= 1;
}
test r expect 36288000;

###
### for..in and iterators
###

@println("*** ITERATORS AND FOR ***");

# an iterator is a function that returns a possibly different value on each call or nil when finished
# we had an example in the sections above (counter).
# assuming it's still in scope...
test counter() expect 4;
test counter() expect 5;
test counter() expect 6;

# you can use an iterator in a for loop
# assuming the same counter is still in scope, it will return 7, 8, 9, ...
let r = 1;
for c in counter {
    if c >=10 { break }
    r *= c;
}
test r expect 504;
test counter() expect 11;

# arrays can also be used in place of iterators
let r = 1;
for a in [1,2,3,4,5,6] {
    r *= a;
}
test r expect 720;

# the standard library contains functions that work on iterators
from @std.iter use range collect;
test collect(range(3,7)) expect [3,4,5,6];
# map was already imported above from @std.array but that is simply an alias to @std.iter.map
test map(\x{x*10},range(0,10)) expect [0,10,20,30,40,50,60,70,80,90];

###
### destructuring
###

@println("*** DESTRUCTURING ***");

# we can split an array with a let binding. 
# this is useful when returning multiple values
# from a function.

let div_mod = fun x y {
    [x // y, x mod y]
};
let [q,r] = div_mod(13,5);
test q expect 2;
test r expect 3;

###
### pipeline operator
###

@println("*** PIPELINE ***");

# sometimes we have a series of 1 argument functions to apply one after the other
# the pipeline syntax makes this easier

# x | f1 | f2 | f3 | f4
# is equivalent to
# f4(f3(f2(f1(x))))

let square = \x{x*x};
let add = \x,y{x+y};

test 2 | square | add(1) | fun a { a * 10 } expect 50;

###
### comments
###

@println("*** COMMENTS ***");

# a line comment starts with # and ends with a new line

@println("this code is active"); # but this is a comment

(# 
a block comment starts with a (# and ends with #)
as you can see above, they can be nested.
#)

# note how block comments can be commented out by 
# putting a # infront of the opening (#
# and the closing #) is self-commenting.
(# this is really cool when you want to activate and deactivate blocks quickly #)

#(#
@println("this code will run because the start of the block comment is commented out");
#)

@println("comments are not (# active #) inside #of strings");

###
### exceptions
###

@println("*** EXCEPTIONS (SPECIAL CONTROL) ***");

# exceptions are constructs that allow exiting the normal flow of operations
# and possibly returning a value

# we have multiple kinds:
# - exit: exits the first block it finds (with optional value)
# - break: exits the first loop it finds (with optional value)
# - continue: next iteration of the first loop it finds
# - return: exits the first function it finds (with optional value)
# - throw: has to be caught manually (with optional value)
# - error: has to be caught manually

let i = 0;
let r = {
    i += 1;
    exit i;
    i += 1
};
test r expect 1;

let i = 0;
let r = loop {
    { exit; i += 1; }
    i += 1;
    break i;
    i += 1
};
test r expect 1;

let f = fun {
    let i = 0;
    let r = loop {
        { exit; i += 1; }
        i += 1;
        return 20;
        i += 1
    };
    r
};
test f() expect 20;

let fe = fun {
    let i = 0;
    let r = loop {
        { exit; i += 1; }
        i += 1;
        throw 30;
        i += 1
    };
    r
};
let tc = try fe() catch e {
    e + 1
};
test tc expect 31;

let err = try 1/0 catch e { @string(e) };
test err expect "division by zero";

