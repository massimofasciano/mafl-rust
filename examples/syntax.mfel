###
### let: create variable bindings
###

# this binds the name x to a memory cell containing the value 10
let x = 10;

# this binds the name x to another memory cell containing the value 20
# the previous x is still there but shadowed.
let x = 20;
# this becomes even more important when using nested code blocks with local scopes

###
### unit testing
###

# the @test builtin function can be used for simple unit tests
let x = 2;
let y = 3;
@test("x + y",5);
# it takes a string as first argument and will treat it as a program to be parsed and evaluated inside 
# the current context. the result is compared to the second argument and a diagnostic message is printed:
# test success: x + y == 5

###
### assign and op-assign: change variable bindings
###

let x = 10;
@test("x",10);

# this changes the content of the memory cell of x and places 20 into it
x = 20;
@test("x",20);

# a shortcut for x = x + 1;
# adds 1 to the value inside the cell
x += 1;
@test("x",21);
# many other op-assign combos exist like *= /= -= etc...

###
### fun: create anonymous functions
###

# closed function: 3 arguments x, y and z
let f = fun x y z { x + y * z };
# f(1,2,3) will return 1 + 2 * 3 = 7 (no outside effects)

# open function: 2 arguments x and y, 1 free variable z
# a reference to z will be looked up when the function is defined
# and will be kept inside a closure (lexical binding)
let z = 40;
let f = fun x y { x + y * z };
@test("f(1,2)",81);

# if the original z is modified, the function will see the change because
# it kept a reference to it. the function can also change z and the outside
# context will see this change in the original.
z += 1;
@test("f(1,2)",83);

# if z is shadowed by a new binding after the function is defined, the old value is used
let z = 50;
@test("f(1,2)",83);

# something like this can be used to create an iterator
let counter = {
    let count = 0;
    fun {
        # this function captures a reference to the 
        # count variable and can update it when called.
        # the add-assign as an expression returns the
        # new value after mutation.
        count += 1 
    }
};
@test("counter()",1);
@test("counter()",2);
@test("counter()",3);

# when we need to refer to our anonymous function recursively, we can use the capture trick...
# - declare f (defaults to nil)
# - the fun expression will capture it by reference
# - store the function in the memory cell that was captured (circular reference)
let f;
f = fun x {
    if x <= 1 { x } else { x * f(x-1) }
};
@test("f(4)",24);
# works even if we change f
let g = f;
let f = fun x { 0 };
@test("g(4)",24);

# we can do mutual recursion (2 functions calling each other) with
# a variant of the capture trick...

# f1 captures the reference to f2 (bound to nil for now)
let f2;
let f1 = fun x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
};
# f2 has captured f1 and replaced the f2 captured inside f1
f2 = fun x {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
};
# we could also directly modify the f2 binding
# that is captured in f1 (if we had used let instead
# of assignment when declaring f2)
# f1.f2 = f2;

@test("f1(5)",5);
@test("f1(15)",-15);
@test("f1(25)",25);


###
### defun
###

# we often define functions so some syntactic sugar is worth it:
defun f x {
    if x <= 1 { x } else { x * f(x-1) }
};
# it's shorter than a let+fun and we also get the circular binding on the
# name of the function in case we need to recurse.
@test("f(4)",24);

# defun does not solve the mutual recursion issue by itself.
# the example above can be rewritten using 2 defun but we still
# need an external binding of f2 to be captured by f1.
# we can change the captured f2 inside f1 by assigning to f1.f2

let f2;
defun f1 x {
    if x < 10 {
        x
    } else {
        f2(x)
    }
}
defun f2 x {
    if x > 20 {
        x
    } else {
        f1(-x)
    }
}
f1.f2 = f2;



###
### a shortcut for small functions: \ ... -> expr
###

let f = \x -> x + 1;
# equivalent to let f = fun x { x + 1 }
@test("f(1)",2);

# works with multiple arguments
let f = \x y z -> x * y * z;
@test("f(1,2,3)",6);

# works with no arguments (but looks strange)
let f = \->1;
@test("f()",1);

# this short syntax looks good when passing a function to another function (with map, filter, etc...)

###
### code blocks
###

# we have seen blocks in the section about functions but code blocks can be used anywhere
# in place of an expression. they create a local scope for variables.

let x = 20;
@test("x",20);
{
    x += 1; # we are still working on the same x as outside
    @test("x",21);
    let x = 30;
    x += 1; # we are working on a local binding of x that shadows the other
    @test("x",31);
}
# as soon as we exit the block, the old binding comes back
@test("x",21);

# a code block has a value as an expression: the value of the last item in the block
let v = { 
    let x = 20;
    x += 2;
    x
};
@test("v",22);

# note that we did not put a semicolon on the last expression
# if we put one, it would be equivalent to having an implicit nil 
# as the last expression in the block
let v = { 
    let x = 20;
    x += 2;
    x; # this does nothing but it's valid
};
@test("v",nil);

###
### context with ... {...} is a shortcut for fun with ... {...}()
### object {...} is a shortcut for fun {...; @self}
### module m {...} is a shortcut for let m = object {...};
###
