(#
let printf = fun fmt vals {
    let delim = "@";
    let parts = @split(fmt,delim);
    @println(parts);
    let i = 0;
    for v in vals {
        if i >= @len(parts)-1 { break };
        @print(parts[i]);
        @print(@string(v));
        i += 1;
    }
    while i < @len(parts) {
        @print(parts[i]);
        i += 1;
    }
};
printf("x=@ y=@ z=@ @@end\n",[1,2,3,4]);
printf("x=@ y=@ z=@\n",[1,2,3,4]);
printf("x=@ y=@ z=@\n",[1,2,3]);
printf("hello\n",[1,2,3,4]);
printf("x=@ y=@ z=@\n",[]);
printf("@\n",[1]);

let x = 100;
let y = 200;
let z = 300;
let c = closed x y {
    module {
        use x y;
    }
};
@debugln(c);

@println(@version);
@println(@os);
@println(@test_pass_count);
@println(@test_fail_count);

let x = x + 1;
@pragma("shadow_local","allow");
let x = x + 1;
{
    let x = x + 2;
}

test 2 + 3 expect 5;
test 2 * 3 expect 5;
test 2 + 3 < 2 * 3;

from @std.iter use map range;
from @std.math use pow log;
from @std.utils use flip;

#map(@exp,range(1,10))
#map(log,range(1,10))
#map(pow(2),range(1,10))
#map(flip(pow,2),range(1,10))

let z = 100;
let df = dyn x y {
    x * y + z
};
let f = fun x y {
    use z;
    df(x,y)
};
f(1,2);


let z = 100;
@println(z);

let d1 = dyn {
    let z = z + 200;
    z
};
@println(d1);


let d2 = dynmut {
    let z = z + 300;
    z
};
@println(d2);

@println(d1());
@println(z);

@println(d2());
@println(z);

#)

@std.prelude();

map(\x{x+1},[1,2,3])

