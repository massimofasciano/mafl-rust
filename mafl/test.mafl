@std.prelude();

# the interpreter supports adding custom builtin vars and functions from Rust
# they can be called like any other builtin.
# based on cargo flag "test_custom", we add @my_custom_var and @my_custom_fn in the interpreter main...

(# 
let x = 10;
let y = 20;
let z = 30;
test @my_custom_var expect [10];
test @my_custom_fn("x","y","z") expect [10,20,30];
#)

let common = module {
    let x = 10;
};

let builder = cons i1 i2 {
    from common use x;
    let y = i1;
    let z = i2;
    let advance = fun n {
        z = z + y + x;
        x += n;
        y *= n;
    };
    let reset = fun {
        y = i1;
        z = i2;
    };
    let to_string = fun {
        "State(" + x + "," + y + "," + z + ")"
    };
    forget i1;
    forget i2;
};

let state1 = builder(1,2);
# at this point state1 is an object containing
# - x: aliased to the x inside common
# - y,z: internal to state1 (values 1 and 2)
# - 3 methods: advance, reset and to_string (called by @println)
# - no i1 or i2 because we forgot them
# but the reset method has captured i1 and i2 in a closure and can use them
# even if the parent forgets them.

let state2 = builder(4,8);
# another instance (with x shared through common)

@println(state1);
@println(state2);

state1.x += 1;

test common.x expect 11;
test state1.x expect 11;
test state2.x expect 11;

@println(state2);
state2.advance(2);
@println(state2);
state2.advance(2);
@println(state2);

test common.x expect 15;
test state1.x expect 15;
test state2.x expect 15;

@println(state1);
@println(state2);

state2.reset();
@println(state1);
@println(state2);