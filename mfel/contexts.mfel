### contexts can be manipulated as first-class objects in the language
###
### a syntactical context block starts with an empty "local" context
### and adds bindings for a list of letiables from the 
### external context ("copies" by value)
### - syntax 1 : context (g1,...,gn) { epr1; expr2;... }
### - syntax 2 : context (g1,...,gn) in expr
###
### contexts can be used as structs or hash maps
### field notation is supported: obj.x, obj.get_y()
###
### the builtin @capture() function "captures" the current environment
### @capture() is equivalent to closure(){}
###

let y := 30;

# note how block comments can be commented out by 
# putting a # infront of the opening (#
# and the closing #) is self-commenting

#(#
let obj := context (y) {
    # example with let
    let x := 10;
    let get_x := closure() {x}; 
    let get_y := closure() {y};
    let set_x := closure(new_x) {x := new_x};
    let set_y := closure(new_y) {y := new_y};
    @capture()
    #closure(){}
};
#)

(#
let obj := context (y) {
    # same example with let .. in ..
    let x := 10 in
    let get_x := closure() {x} in
    let get_y := closure() {y} in
    let set_x := closure(new_x) {x := new_x} in
    let set_y := closure(new_y) {y := new_y} in
    #@capture()
    closure(){}
};
#)

@println(obj.get_x());
@println(obj.y);
obj.set_x(obj.x + 1);
obj.set_y(obj.y + 5);
@println(obj.x);
@println(obj.get_y());
y
