# fix infix function op

#var add = function(x,y) { x+y };
#add(1,2) $add 3
#1 $add 2
#2 $@pow 3
#2 ^ 3

#var x = 100;
#let x = 10 in x + 1; x

(#
var x = let i = 0 in let j = 1 in while i < 10 {
    @print(i);
    i := i + 1;
    j := j * 2
};
x
#)

@eval("@println(\"hello\")");
var add = function(x,y) { x+y };
var f = function (x) {
    if x = () {
        ()
    } 
    else {
        if x > 5 {
            ()
        } else {
            x+1
        }
    }
};
var x = ();
@println(x);
@println(x := 3);
@println(x);
#f(f(f(f(f(f(f(1)))))))
#1 | f | f | f | f | f | f | f
#1 | f | add(2) | f

let o = {
    var x = 1;
    var f = function(y) { x + y };
    function() {}
} in {
    @println(o.f(5));
    o.f := add;
    @println(o.f(5,6));
};

var test = function (a,b,c,d) { function (x) { @println(x); a+b*c+d } };

var rec = function (x) {x};
var rec = context () {
    function (x) {if x<1 {1} else {2*rec(x-1)}}
};
#rec(4)

(#
let fibo = context () {
    function (x) {
        if x < 2 {
            x
        } else {
            fibo(x-2) + fibo(x-1)
        }
    }
} in fibo(34)
#)

# this example never works because of a cloned context in closure application
# (q is never mutated in the global context via function p)
var q = 1;
q := q + 1;
#var p = context (q) { function () { q := q + 1; @println(q) } };
var p = function () { q := q + 1; @println(q) };
p
