WHITESPACE = _{ " " | "\t" | NEWLINE }

// python-style line comments starting with #
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

reserved = _{
    "if" | "else" | "while" | "unless" | "do" |
    "return" | "break" | "continue" |
    "let" | "fn" | 
    "true" | "false" |
    "and" | "or" | "not"
}

identifier = @{ 
    !reserved ~
    (ASCII_ALPHA | "_") ~ 
    (ASCII_ALPHANUMERIC | "_")* 
}
infix_identifier = ${
    "@" ~ identifier
}
integer = @{ 
    "-"? ~ ASCII_DIGIT+ 
}
float = @{
    "-"? ~
    ASCII_DIGIT+ ~ &("."|"e") ~
    ("." ~ ASCII_DIGIT+)? ~
    (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
unit_literal = @{ "()" }
boolean = _{ true | false }
true = { "true" }
false = { "false" }

string_literal = ${ "\"" ~ string ~ "\"" } // can't make this silent (in this version)
string = @{ 
    (
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
    )* 
}

function_args = { (identifier ~ ("," ~ identifier)*)? }
function = {
    "fn" ~ "(" ~ function_args ~ ")" ~ block
}

if = {
    "if" ~ expr ~ block ~ ("else" ~ block)?
}

unless = {
    "unless" ~ expr ~ block
}

while = {
    "while" ~ expr ~ block
}

do_while = {
    "do" ~ block ~ "while" ~ "(" ~ expr ~ ")"
}

loop = {
    "loop" ~ block
}

let = {
    "let" ~ identifier ~ ":=" ~ expr
}

return = {
    "return" ~ expr?
}
continue = { "continue" }
break = { "break" }

block = {
    "{" ~ sequence ~ "}"
}

apply_args = {
    "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"
}

question = { "?" }
exclam = { "!" }
neg = { "-" }
not = { "not" }
dollar = { "$" }
add = { "+" }
sub = { "-" }
mult = { "*" }
div = { "/" }
ge = { ">=" }
le = { "<=" }
gt = { ">" }
lt = { "<" }
eq = { "=" }
ne = { "!=" | "<>" }
and = { "and" }
or = { "or" }

dot_apply = { "." ~ identifier ~ apply_args }

expr = _{ expr_infix_id }
expr_infix_id = { expr_or ~ (infix_identifier ~ expr_or)* }
expr_or = { expr_and ~ (or ~ expr_and)* }
expr_and = { expr_eq ~ (and ~ expr_eq)* }
expr_eq = { expr_rel ~ ((eq|ne) ~ expr_rel)* }
expr_rel = { expr_add ~ ((ge|le|gt|lt) ~ expr_add)* }
expr_add = { expr_mul ~ ((add|sub) ~ expr_mul)* }
expr_mul = { expr_post ~ ((mult|div) ~ expr_post)* }
expr_post = { expr_dotcall ~ (question|exclam)* }
// expr_dotcall = { expr_apply ~ ("." ~ identifier ~ apply_args)* }
// expr_apply = { expr_prefix ~ apply_args? }
expr_dotcall = _{ expr_apply }
expr_apply = { expr_prefix ~ (apply_args | dot_apply)* }
expr_prefix = { (not|neg|dollar)* ~ expr_base }
expr_base = _{
    "(" ~ expr ~ ")" | 
    block | if | 
    while | unless | do_while | loop |
    let | function | 
    return | continue | break |
    boolean | float | integer | string_literal | identifier | unit_literal
}

// expressions that behave like blocks
expr_block = _{ block | if | while | unless | loop }

semicolons = _{ ";" ~ semicolons | ";" }
unit_implicit = { "" }
// sequence = expressions separated by semicolon(s)
// expressions that behave like blocks don't need the semicolon
// if trailing semicolon, implicit unit value is added
sequence = _{ sequence_nonempty | sequence_empty }
sequence_nonempty = _{
    expr_block ~ sequence_nonempty | expr ~ semicolons ~ sequence | expr
}
sequence_empty = _{ unit_implicit }

// a program file is a sequence of expressions
file = {
    SOI ~ sequence ~ EOI
}

