WHITESPACE = _{ " " | "\t" | NEWLINE }

COMMENT = _{ block_comment | line_comment }
// python-style line comments starting with #
line_comment_start = @{ "#" }
line_comment = @{ line_comment_start ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
// recursive block comments (# ... #)
block_comment_start = @{ "(#" }
block_comment_end = @{ "#)" }
block_comment = @{ 
    block_comment_start ~ 
    (!(block_comment_end|block_comment_start) ~ ANY)* ~ 
    block_comment? ~ 
    (!block_comment_end ~ ANY)* ~ (block_comment_end | EOI) 
}

reserved = _{
    "if" | "else" | "while" | "unless" | "do" |
    "return" | "break" | "continue" |
    "let" | "lambda" | "var" | "in" | 
    "true" | "false" |
    "and" | "or" | "not"
}

identifier = @{ 
    !reserved ~
    (ASCII_ALPHA | "_") ~ 
    (ASCII_ALPHANUMERIC | "_")* 
}
infix_identifier = ${
    "$" ~ ( builtin | identifier )
}
builtin = ${
    "@" ~ identifier
}
integer = @{ 
    "-"? ~ ASCII_DIGIT+ 
}
float = @{
    "-"? ~
    ASCII_DIGIT+ ~ &("."|"e") ~
    ("." ~ ASCII_DIGIT+)? ~
    (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
unit_literal = @{ "()" }
boolean = _{ true | false }
true = { "true" }
false = { "false" }

string_literal = ${ "\"" ~ string ~ "\"" } // can't make this silent (in this version)
string = @{ 
    (
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
    )* 
}

function_args = { (identifier ~ ("," ~ identifier)*)? }
function = {
    "lambda" ~ "(" ~ function_args ~ ")" ~ block
}

if = {
    "if" ~ expr ~ block ~ ("else" ~ block)?
}

unless = {
    "unless" ~ expr ~ block
}

while = {
    "while" ~ expr ~ block
}

do_while = {
    "do" ~ block ~ "while" ~ "(" ~ expr ~ ")"
}

loop = {
    "loop" ~ block
}

let_in = {
    "let" ~ identifier ~ "=" ~ expr ~ "in" ~ expr
}

var = {
    "var" ~ identifier ~ "=" ~ expr
}

assign = {
    identifier ~ ":=" ~ expr
}

return = {
    "return" ~ expr?
}
continue = { "continue" }
break = { "break" }

block = {
    "{" ~ sequence ~ "}"
}

apply_args = {
    "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"
}

variable = { identifier | builtin }

question = @{ "?" }
exclam = @{ "!" ~ !"=" }
neg = @{ "-" }
not = @{ "not" }
ref = @{ "&" }
deref = @{ "*" }
add = @{ "+" }
sub = @{ "-" }
mult = @{ "*" ~ !"*" }
div = @{ "/" }
mod = @{ "mod" | "%" }
ge = @{ ">=" }
le = @{ "<=" }
gt = @{ ">" ~ !"=" }
lt = @{ "<" ~ !"=" }
eq = @{ "=" }
ne = @{ "!=" | "<>" }
and = @{ "and" }
or = @{ "or" }
exp = @{ "**" | "^" }

field_access = { "." ~ identifier }

expr = _{ expr_infix_id }
expr_infix_id = { expr_or ~ (infix_identifier ~ expr_or)* }
expr_or = { expr_and ~ (or ~ expr_and)* }
expr_and = { expr_eq ~ (and ~ expr_eq)* }
expr_eq = { expr_rel ~ ((eq|ne) ~ expr_rel)* }
expr_rel = { expr_add ~ ((ge|le|gt|lt) ~ expr_add)* }
expr_add = { expr_mul ~ ((add|sub) ~ expr_mul)* }
expr_mul = { expr_exp ~ ((mult|div) ~ expr_exp)* }
expr_exp = { expr_post ~ (exp ~ expr_post)* }
expr_post = { expr_apply_or_field ~ (question|exclam)* }
expr_apply_or_field = { expr_prefix ~ (apply_args | field_access)* }
expr_prefix = { (not|neg|ref|deref)* ~ expr_base }
expr_base = _{
    "(" ~ expr ~ ")" | 
    block | if | 
    while | unless | do_while | loop |
    var | let_in | function | assign |
    return | continue | break |
    boolean | float | integer | string_literal | variable | unit_literal
}

// expressions that behave like blocks
expr_block = _{ block | if | while | unless | loop }

semicolons = _{ ";" ~ semicolons | ";" }
unit_implicit = { "" }
// sequence = expressions separated by semicolon(s)
// expressions that behave like blocks don't need the semicolon
// if trailing semicolon, implicit unit value is added
sequence = _{ sequence_nonempty | sequence_empty }
sequence_nonempty = _{
    expr_block ~ sequence_nonempty | expr ~ semicolons ~ sequence | expr
}
sequence_empty = _{ unit_implicit }

// a program file is a sequence of expressions
file = {
    SOI ~ sequence ~ EOI
}

