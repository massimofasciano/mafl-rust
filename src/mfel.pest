WHITESPACE = _{ " " | "\t" | NEWLINE }

COMMENT = _{ block_comment | line_comment }
// python-style line comments starting with #
line_comment_start = @{ "#" }
line_comment = @{ line_comment_start ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
// recursive block comments (# ... #)
block_comment_start = @{ "(#" }
block_comment_end = @{ "#)" }
block_comment = @{ 
    block_comment_start ~ 
    (!(block_comment_end|block_comment_start) ~ ANY)* ~ 
    block_comment? ~ 
    (!block_comment_end ~ ANY)* ~ (block_comment_end | EOI) 
}

reserved = _{
    "if" | "else" | "while" | "unless" | "do" | "for" |
    "return" | "break" | "continue" |
    "let" | "function" | "def" | "closure" | "staticfn" | "in" | 
    "context" | "module" |
    "true" | "false" | "nil" |
    "and" | "or" | "not"
}

identifier_syntax = @{
    (ASCII_ALPHA | "_") ~ 
    (ASCII_ALPHANUMERIC | "_")* 
}
identifier = @{ !reserved ~ identifier_syntax | reserved ~ identifier_syntax }

infix_identifier = ${
    "`" ~ ( builtin | identifier ) ~ "`"
}
builtin = ${
    "@" ~ identifier_syntax
}
integer = @{ 
    "-"? ~ ASCII_DIGIT+ 
}
float = @{
    "-"? ~
    ASCII_DIGIT+ ~ &("."|"e") ~
    ("." ~ ASCII_DIGIT+)? ~
    (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
nil_literal = @{ "nil" }
boolean = _{ true | false }
true = { "true" }
false = { "false" }

char_literal = ${ "'" ~ character ~ "'"}
character = @{ !"'" ~ ( "\\" ~ ("b" | "f" | "n" | "r" | "t") | ANY ) }

string_literal = ${ "\"" ~ string ~ "\"" } // can't make this silent (in this version)
string = @{ 
    (
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
    )* 
}

array = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]"}

function_args = { (identifier ~ ("," ~ identifier)*)? }

function = {
    "dynfn" ~ "(" ~ function_args ~ ")" ~ block
}

closure = {
    "lambda" ~ "(" ~ function_args ~ ")" ~ block
}

staticfn = {
    "staticfn" ~ "(" ~ function_args ~ ")" ~ block
}

def = {
    "def" ~ identifier ~ "(" ~ function_args ~ ")" ~ block
}

context = {
    "context" ~ "(" ~ function_args ~ ")" ~ ( ("in" ~ expr) | block )
}

module = {
    "module" ~ identifier ~ "(" ~ function_args ~ ")" ~ block_syntax
}

if = {
    "if" ~ expr ~ block ~ ("else" ~ block)?
}

unless = {
    "unless" ~ expr ~ block
}

while = {
    "while" ~ expr ~ block_syntax
}

do_while = {
    "do" ~ block_syntax ~ "while" ~ "(" ~ expr ~ ")"
}

loop = {
    "loop" ~ block_syntax
}

for = {
    "for" ~ variable ~ "in" ~ expr ~ block_syntax
}

let_in = {
    "let" ~ identifier ~ "=" ~ expr ~ "in" ~ expr
}

let = {
    "let" ~ identifier ~ ":=" ~ expr
}

assign = {
    // identifier ~ field_access* ~ ":=" ~ expr
    identifier ~ ":=" ~ expr
}

return = {
    "return" ~ expr?
}
continue = { "continue" }
break = { "break" }

block = {
    "{" ~ sequence ~ "}"
}

block_syntax = {
    "{" ~ sequence ~ "}"
}

apply_args = {
    "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"
}

variable = { identifier | builtin }

question = @{ "?" }
exclam = @{ "!" ~ !"=" }
neg = @{ "-" }
not = @{ "not" }
ref = @{ "&" }
deref = @{ "*" }
add = @{ "+" }
sub = @{ "-" }
mult = @{ "*" ~ !"*" }
div = @{ "/" }
mod = @{ "mod" | "%" }
ge = @{ ">=" }
le = @{ "<=" }
gt = @{ ">" ~ !"=" }
lt = @{ "<" ~ !"=" }
eq = @{ "==" }
ne = @{ "!=" | "<>" }
and = @{ "and" }
or = @{ "or" }
exp = @{ "**" | "^" }
pipe = @{ "|" }

field_access = { "." ~ identifier }

expr = _{ expr_infix_pipe }
expr_infix_pipe = { expr_infix_id ~ (pipe ~ expr_infix_id)* }
expr_infix_id = { expr_or ~ (infix_identifier ~ expr_or)* }
expr_or = { expr_and ~ (or ~ expr_and)* }
expr_and = { expr_eq ~ (and ~ expr_eq)* }
expr_eq = { expr_rel ~ ((eq|ne) ~ expr_rel)* }
expr_rel = { expr_add ~ ((ge|le|gt|lt) ~ expr_add)* }
expr_add = { expr_mul ~ ((add|sub) ~ expr_mul)* }
expr_mul = { expr_exp ~ ((mult|div|mod) ~ expr_exp)* }
expr_exp = { expr_post ~ (exp ~ expr_post)* }
expr_post = { expr_apply_or_field ~ (question|exclam)* }
expr_apply_or_field = { expr_prefix ~ (apply_args | field_access)* }
expr_prefix = { (not|neg|ref|deref)* ~ expr_base }
expr_base = _{
    "(" ~ expr ~ ")" | nil_literal |
    array |
    block | if | 
    while | unless | do_while | loop | for |
    let | let_in | def | function | closure | staticfn | assign | context | module |
    return | continue | break |
    boolean | float | integer | string_literal | char_literal | variable 
}

// expressions that behave like blocks
expr_block = _{ block | if | while | unless | loop | for | def | module }

semicolons = _{ ";" ~ semicolons | ";" }
nil_implicit = { "" }
// sequence = expressions separated by semicolon(s)
// expressions that behave like blocks don't need the semicolon
// if trailing semicolon, implicit nil value is added
sequence = _{ sequence_nonempty | sequence_empty }
sequence_nonempty = _{
    expr_block ~ sequence_nonempty | expr ~ semicolons ~ sequence | expr
}
sequence_empty = _{ nil_implicit }

// a program file is a sequence of expressions
file = {
    SOI ~ sequence ~ EOI
}

