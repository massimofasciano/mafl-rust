###
### this is the MFEL embedded standard library
###
### it is visible through the @std module (ex: @std.array.map)
###

### prelude that loads essentials when called.
### use at top level or in dynamic context, 
### not inside a closure (fun/cons/module).
### usage: @std.prelude();
let prelude = dynmut {
    from @std.utils use flip;
    from @std.math use add sub mul div exp log pow;
    from @std.time use elapsed;
    from @std.iter use range map fold;
};

## utility functions
let utils = module {
    let flip = fun f { fun x y { f(y,x) } };
};

## math functions
let math = module {
    let add = fun x y { x + y };
    let sub = fun x y { x - y };
    let mul = fun x y { x * y };
    let div = fun x y { x / y };
    let exp = fun x { @exp(x) };
    let log = fun x { @log(x) };
    let pow = fun x y { @pow(x,y) };
};

## time calculations
let time = module {
    let start = @now();
    let elapsed = fun {
        @now() - start
    };
};

## iterators and iterator functions
let iter = module {
    let range = fun start end {
        fun {
            if start < end {
                let count = start;
                start += 1;
                count            
            }
        }
    };
    let collect = fun iter {
        let out = @make_array(0,nil);
        for e in iter { @append(out,e); }
        out
    };
    let map = fun f iter {
        let out = @make_array(0,nil);
        for e in iter { @append(out,f(e)); }
        out
    };
    let fold = fun f acc iter {
        for e in iter { acc = f(acc,e) }
        acc
    };
    let sum = fun iter {
        fold(\x,y{x+y}, 0, iter)
    };
    let prod = fun iter {
        fold(\x,y{x*y}, 1, iter)
    };
    let filter = fun f iter {
        let out = @make_array(0,nil);
        for e in iter {
            if f(e) { @append(out,e); }
        }
        out
    };
    let foreach = fun f a {
        for e in a { f(e) }
    };
};

## array functions
let array = module {
    from iter use map fold sum prod filter foreach;
    let reduce = fun f arr {
        if @len(arr) < 1 { 
            @error("reduce called on empty array")
        } else {
            let acc = arr[0];
            let i = 1;
            while i < @len(arr) {
                acc = f(acc,arr[i]);
                i += 1;
            }
            acc
        }
    };
    let reverse = fun arr {
        # reverses the array in place
        let back = @len(arr)-1;
        let front = 0;
        while back > front {
            let tmp = arr[back];
            arr[back] = arr[front];
            arr[front] = tmp;
            back -= 1;
            front += 1;
        }
        arr
    };
};
