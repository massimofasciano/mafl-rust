###
### this is the MFEL embedded standard library
###
### it is visisible through the @std module (ex: @std.array.map)
###

## iterators and iterator functions
let iter := capture () {
    let range := staticfn(start,end) {
        closure() {
            if start < end {
                let count := start;
                start := start + 1;
                count            
            }
            # no else clause means return unit when condition is false
        }
    };
    let collect := staticfn (iter) {
        let out := @array(0,());
        for e in iter { @append(out,e); }
        out
    };
    let map := staticfn (f,iter) {
        let out := @array(0,());
        for e in iter { @append(out,f(e)); }
        out
    };
    let fold := staticfn (f,acc,iter) {
        for e in iter { acc := f(acc,e) }
        acc
    };
    let sum := context (fold) in closure(iter) {
        fold(function(x,y){x+y}, 0, iter)
    };
    let prod := context (fold) in closure(iter) {
        fold(function(x,y){x*y}, 1, iter)
    };
    let filter := staticfn (f,iter) {
        let out := @array(0,());
        for e in iter {
            if f(e) { @append(out,e); }
        }
        out
    };
    let foreach := staticfn (f,a) {
        for e in a { f(e) }
    };
};

## array functions
let array := capture () {
    let reduce := staticfn (f,arr) {
        if @len(arr) < 1 {
            ()
        } else {
            let acc := arr(0);
            let i := 1;
            while i < @len(arr) {
                acc := f(acc,arr(i));
                i := i + 1;
            }
            acc
        }
    };
    let reverse := staticfn (arr) {
        # reverses the array in place
        let back := @len(arr)-1;
        let front := 0;
        while back > front {
            let tmp := arr(back);
            arr(back,arr(front));
            arr(front,tmp);
            back := back - 1;
            front := front + 1;
        }
        arr
    };
};
